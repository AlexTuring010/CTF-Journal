# Διαλέξεις και Buffer Overflow Attack

## Διαλέξεις

- [Διάλεξη 1](https://delos.uoa.gr/opendelos/videolecture/show?rid=c9554f73)
- [Διάλεξη 2](https://delos.uoa.gr/opendelos/videolecture/show?rid=5ddddcb3)

## Περιεχόμενο

Στις παραπάνω διαλέξεις εξετάσαμε:

1. **Εισαγωγή στην x86 Assembly**: Μια σύντομη επισκόπηση της αρχιτεκτονικής και των βασικών εντολών.
2. **Ανάλυση προγραμμάτων μέσω εργαλείων**:
   - Χρήση του `objdump` για αποσυναρμολόγηση (disassembly) εκτελέσιμων αρχείων.
   - Χρήση του `gdb` για δυναμική ανάλυση και debugging.
3. **Εκμετάλλευση Buffer Overflow**:
   - Πώς μπορούμε να εκμεταλλευτούμε σφάλματα διαχείρισης μνήμης.
   - Επιθέσεις buffer overflow και τρόποι πρόκλησής τους.

Οι παραπάνω τεχνικές αποτελούν θεμελιώδεις αρχές στην ασφάλεια συστημάτων και την ανάλυση κακόβουλου λογισμικού.

Κατανοητό! Θα κάνω τη διόρθωση ώστε να συμπεριληφθεί η εξήγηση που αναφέραμε για το πώς οι διευθύνσεις που βλέπουμε στο `objdump` είναι relative και πώς αυτό συνδέεται με το πραγματικό εκτελέσιμο πρόγραμμα, καθώς και γιατί πρέπει να χρησιμοποιούμε τη διεύθυνση από το `gdb` στο payload.

---

## Εισαγωγή στο objdump και ανάλυση του buf0

Το `objdump` είναι ένα εργαλείο που μας επιτρέπει να αναλύσουμε το περιεχόμενο εκτελέσιμων αρχείων και να δούμε τη δομή τους. Όταν το χρησιμοποιούμε για αποσυναρμολόγηση ενός εκτελέσιμου αρχείου (όπως το `buf0`), μπορούμε να βρούμε τη διεύθυνση της συνάρτησης `thank_you`, όμως πρέπει να λάβουμε υπόψη ότι οι διευθύνσεις που εμφανίζονται μέσω του `objdump` είναι συνήθως **relative** προς τη βάση του εκτελέσιμου αρχείου. Αυτό σημαίνει ότι όταν το πρόγραμμα εκτελείται, η διεύθυνση που βλέπουμε στο `objdump` μπορεί να μην αντιστοιχεί ακριβώς στην πραγματική διεύθυνση στη μνήμη.

Για να το καταλάβουμε καλύτερα, η διεύθυνση που βλέπουμε στο `objdump` είναι **relative** στην τοποθεσία φόρτωσης του εκτελέσιμου στο μνήμη (εξαιτίας του address space layout randomization – ASLR). Αυτό σημαίνει ότι όταν το πρόγραμμα φορτώνεται στη μνήμη, η πραγματική του βάση αλλάζει, και η διεύθυνση που βλέπουμε μέσω του `objdump` ίσως να μην είναι ακριβής.

Για να βρούμε τη σωστή διεύθυνση κατά την εκτέλεση του προγράμματος, πρέπει να χρησιμοποιήσουμε ένα εργαλείο όπως το `gdb` για να **εκτελέσουμε** το πρόγραμμα και να πάρουμε τις πραγματικές διευθύνσεις στη μνήμη του προγράμματος.

---

### Βήματα για να βρούμε τη σωστή διεύθυνση της συνάρτησης `thank_you`:

1. **Χρήση του `objdump`**:

   Αν και οι διευθύνσεις στο `objdump` είναι relative, μπορούμε να το χρησιμοποιήσουμε για να δούμε την αρχική διεύθυνση της συνάρτησης `thank_you` στο εκτελέσιμο:

   ```sh
   objdump -d buf0 | grep thank_you
   ```

   Αυτό θα επιστρέψει τη relative διεύθυνση της συνάρτησης στο εκτελέσιμο. Ωστόσο, αυτή η διεύθυνση δεν είναι επαρκής για την εκτέλεση του exploit, καθώς η διεύθυνση στη μνήμη θα διαφέρει όταν το πρόγραμμα τρέξει.

2. **Χρήση του `gdb` για να βρούμε τη πραγματική διεύθυνση**:

   Αν θέλουμε να εκμεταλλευτούμε την ευπάθεια buffer overflow και να καλέσουμε τη συνάρτηση `thank_you`, πρέπει να ξέρουμε την **πραγματική διεύθυνση** της συνάρτησης στη μνήμη κατά τη διάρκεια της εκτέλεσης. Ο τρόπος να το πετύχουμε είναι να χρησιμοποιήσουμε το `gdb`, το οποίο επιτρέπει να εντοπίσουμε τη διεύθυνση που αντιστοιχεί στη συνάρτηση κατά την εκτέλεση του προγράμματος.

   - Ξεκινάμε το πρόγραμμα με το `gdb`:

     ```sh
     gdb ./buf0
     ```

   - Όταν το πρόγραμμα φορτωθεί στο `gdb`, μπορούμε να ορίσουμε ένα breakpoint και να εκτελέσουμε το πρόγραμμα:

     ```sh
     break main
     run <όρισμα>
     ```

   - Όταν το πρόγραμμα σταματήσει στο breakpoint, μπορούμε να εκτυπώσουμε την πραγματική διεύθυνση της συνάρτησης `thank_you`:

     ```sh
     info address thank_you
     ```

   Αυτή η εντολή θα επιστρέψει την πραγματική διεύθυνση που έχει καταχωρηθεί στη μνήμη κατά την εκτέλεση του προγράμματος, την οποία μπορούμε να χρησιμοποιήσουμε στο payload για την εκμετάλλευση του buffer overflow.

### Συμπέρασμα:

Αν και το `objdump` μας δίνει μια πρώτη ένδειξη για τη θέση των συναρτήσεων, η πραγματική διεύθυνση που πρέπει να χρησιμοποιήσουμε στο exploit θα πρέπει να ληφθεί κατά την εκτέλεση του προγράμματος μέσω εργαλείων όπως το `gdb`, καθώς οι διευθύνσεις που εμφανίζονται στο `objdump` είναι relative και ενδέχεται να αλλάζουν όταν το πρόγραμμα φορτώνεται στη μνήμη.

---

### Χρήσιμες Εντολές `gdb`

- **Προβολή της τιμής στη διεύθυνση που δείχνει ο καταχωρητής του δείκτη στοίβας**:

  Για να δούμε την τιμή στη διεύθυνση που δείχνει ο δείκτης στοίβας (`$rsp` για x86_64 ή `$esp` για x86):

  ```sh
  x/x $rsp  # Για x86_64
  x/x $esp  # Για x86
  ```

  Αυτή η εντολή θα δείξει την τιμή στη διεύθυνση που δείχνει ο δείκτης στοίβας σε δεκαεξαδική μορφή.

- **Προβολή της τιμής ως string**:

  Για να ερμηνεύσουμε την τιμή στη διεύθυνση ως string:

  ```sh
  x/s $rsp  # Για x86_64
  x/s $esp  # Για x86
  ```

- **Προβολή των 5 πρώτων τιμών του δείκτη στοίβας**:

  Για να δούμε τις πρώτες 5 τιμές του δείκτη στοίβας:

  ```sh
  x/5x $rsp  # Για x86_64 ή x86
  ```

  Αυτή η εντολή θα εμφανίσει τις πρώτες 5 τιμές από την τοποθεσία που δείχνει ο δείκτης στοίβας σε δεκαεξαδική μορφή.

- **Αν μία από αυτές τις τιμές είναι δείκτης σε string**:

  Αν μία από τις τιμές που βρίσκουμε είναι δείκτης σε string, μπορούμε να δούμε το string ακολουθώντας τη διεύθυνση:

  Για παράδειγμα, αν η τιμή είναι `0x7ffff7b0` και αυτή είναι διεύθυνση σε string, τότε χρησιμοποιούμε:

  ```sh
  x/s 0x7ffff7b0  # Αν 0x7ffff7b0 είναι διεύθυνση σε string
  ```

  Αυτή η εντολή θα εμφανίσει το string που βρίσκεται στη διεύθυνση `0x7ffff7b0`.

- **Προβολή της εντολής που δείχνει ο δείκτης εντολών (instruction pointer)**:

  Για να δούμε την εντολή που δείχνει ο δείκτης εντολών (`$rip` για x86_64 ή `$eip` για x86):

  ```sh
  x/i $rip  # Για x86_64
  x/i $eip  # Για x86
  ```

- **Προβολή των επόμενων 5 εντολών από την τοποθεσία του δείκτη εντολών**:

  Για να δούμε τις επόμενες 5 εντολές από το σημείο που βρίσκεται ο δείκτης εντολών:

  ```sh
  x/5i $rip  # Για x86_64
  x/5i $eip  # Για x86
  ```

- **Αποσυναρμολόγηση της συνάρτησης `main`**:

  Για να δούμε την αποσυναρμολόγηση (Assembly κώδικα) της συνάρτησης `main`:

  ```sh
  disas main
  ```

  Αυτή η εντολή θα εμφανίσει τον Assembly κώδικα για τη συνάρτηση `main`, όπου μπορείς να δεις τις εντολές που εκτελούνται όταν το πρόγραμμα φτάνει στη συνάρτηση `main`. Αυτός ο κώδικας μπορεί να είναι χρήσιμος για να κατανοήσεις τον τρόπο με τον οποίο το πρόγραμμα χειρίζεται τη μνήμη, τους καταχωρητές και την στοίβα.

- **Προβολή των μνήμης περιοχών του προγράμματος**:

  Για να δεις τις μνήμης περιοχές (memory mappings) του προγράμματος, χρησιμοποιείς την εντολή:

  ```sh
  info proc mappings
  ```

  Αυτή η εντολή θα εμφανίσει τις περιοχές μνήμης που έχει δεσμεύσει το πρόγραμμα κατά την εκτέλεσή του. Θα μπορέσεις να δεις τη διεύθυνση βάσης για τα δεδομένα και τον κώδικα, καθώς και άλλες χρήσιμες πληροφορίες που αφορούν τη διαχείριση της μνήμης από το πρόγραμμα.
