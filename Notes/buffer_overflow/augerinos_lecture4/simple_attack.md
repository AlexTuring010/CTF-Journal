# Διαλέξεις και Buffer Overflow Attack

## Διαλέξεις

- [Διάλεξη 1](https://delos.uoa.gr/opendelos/videolecture/show?rid=c9554f73)
- [Διάλεξη 2](https://delos.uoa.gr/opendelos/videolecture/show?rid=5ddddcb3)

## Περιεχόμενο

Στις παραπάνω διαλέξεις εξετάσαμε:

1. **Εισαγωγή στην x86 Assembly**: Μια σύντομη επισκόπηση της αρχιτεκτονικής και των βασικών εντολών.
2. **Ανάλυση προγραμμάτων μέσω εργαλείων**:
   - Χρήση του `objdump` για αποσυναρμολόγηση (disassembly) εκτελέσιμων αρχείων.
   - Χρήση του `gdb` για δυναμική ανάλυση και debugging.
3. **Εκμετάλλευση Buffer Overflow**:
   - Πώς μπορούμε να εκμεταλλευτούμε σφάλματα διαχείρισης μνήμης.
   - Επιθέσεις buffer overflow και τρόποι πρόκλησής τους.

Οι παραπάνω τεχνικές αποτελούν θεμελιώδεις αρχές στην ασφάλεια συστημάτων και την ανάλυση κακόβουλου λογισμικού.

## Εισαγωγή στο objdump και ανάλυση του buf0

Το `objdump` είναι ένα εργαλείο που μας επιτρέπει να αναλύσουμε το περιεχόμενο εκτελέσιμων αρχείων. Μπορούμε να το χρησιμοποιήσουμε για να βρούμε τη διεύθυνση της συνάρτησης `thank_you` στο εκτελέσιμο `buf0`.

Για να δούμε την διεύθυνση της συνάρτησης, εκτελούμε την παρακάτω εντολή:

```sh
objdump -d buf0 | grep thank_you
```

Αυτό θα μας επιστρέψει τη διεύθυνση μνήμης όπου βρίσκεται η συνάρτηση `thank_you`, κάτι που είναι χρήσιμο για την επίθεση buffer overflow που θα κάνουμε.

## Ανάλυση του Κώδικα και Εκμετάλλευση Buffer Overflow

Ο παρακάτω κώδικας περιέχει μια ευπάθεια buffer overflow:

```c
void thank_you()
{
    execl("/bin/sh", "sh", NULL);
}

void print(char *message)
{
    char buffer[64];
    strcpy(buffer, message);
    printf("%s\n", buffer);
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s <name>\n", argv[0]);
        return 1;
    }
    print(argv[1]);
    return 0;
}
```

### Πώς λειτουργεί η στοίβα (stack)

Η συνάρτηση `print` αποθηκεύει το όρισμα `message` σε ένα τοπικό buffer 64 bytes (`char buffer[64]`). Ωστόσο, χρησιμοποιεί τη `strcpy`, η οποία δεν ελέγχει το μέγεθος του `message`. Αν το `message` είναι μεγαλύτερο από 64 bytes, τα επιπλέον δεδομένα θα υπερχειλίσουν τον buffer, αντικαθιστώντας άλλες τιμές στη στοίβα, συμπεριλαμβανομένης της διεύθυνσης επιστροφής της συνάρτησης.

### Εκμετάλλευση της ευπάθειας

Εάν παρέχουμε μια είσοδο μεγαλύτερη από 64 bytes, μπορούμε να τροποποιήσουμε τη διεύθυνση επιστροφής της `print` και να την ανακατευθύνουμε στη `thank_you`. Αυτό μπορεί να γίνει ως εξής:

1. Στέλνουμε 64 bytes τυχαίων δεδομένων ώστε να γεμίσουμε το buffer.
2. Προσθέτουμε τη διεύθυνση της `thank_you` ως νέα διεύθυνση επιστροφής.
3. Όταν η `print` ολοκληρωθεί, ο έλεγχος του προγράμματος μεταφέρεται στη `thank_you`, η οποία εκτελεί ένα κέλυφος (`/bin/sh`).

Αυτή η τεχνική χρησιμοποιείται σε κλασικές επιθέσεις buffer overflow για την εκτέλεση αυθαίρετου κώδικα.

## Εισαγωγή στο gdb και Ανάλυση Προγράμματος

Το `gdb` είναι ένας αποσφαλματωτής (debugger) που μας επιτρέπει να αναλύσουμε και να εκτελέσουμε βήμα προς βήμα ένα πρόγραμμα.

### Βασικές εντολές:

- **Εκκίνηση του προγράμματος μέσα στο gdb**:

  ```sh
  gdb ./buf0
  ```

  Αυτό ανοίγει το εκτελέσιμο `buf0` στο `gdb`.

- **Εκτέλεση του προγράμματος**:

  ```sh
  run <όρισμα>
  ```

  Ξεκινά την εκτέλεση του προγράμματος με το παρεχόμενο όρισμα. Το `<όρισμα>` είναι το string που περνάμε στο πρόγραμμα. Για παράδειγμα:

  ```sh
  run AAAAAAAAAA
  ```

  Αυτό δίνει ως όρισμα στο πρόγραμμα το string `AAAAAAAAAA`.

- **Επανάληψη της εκτέλεσης μετά το τέλος του προγράμματος**:

  ```sh
  run
  ```

  Ξανατρέχει το πρόγραμμα από την αρχή χωρίς να χρειάζεται να κλείσουμε το `gdb`.

- **Ορισμός σημείου διακοπής (breakpoint)**:

  ```sh
  break main
  ```

  Αυτό σταματά την εκτέλεση του προγράμματος όταν εισέρχεται στη `main`.

- **Συνέχιση μετά από breakpoint**:

  ```sh
  continue
  ```

- **Εμφάνιση καταχωρητών (π.χ. δείκτης στοίβας)**:

  ```sh
  info registers
  ```

- **Προβολή της τιμής του καταχωρητή του pointer εντολών:**:

  ```sh
  p $rip  # Για αρχιτεκτονική x86_64
  p $eip  # Για αρχιτεκτονική x86
  ```

- **Προβολή της τιμής του καταχωρητή της στοίβας:**:

  ```sh
  p $rsp  # Για αρχιτεκτονική x86_64
  p $esp  # Για αρχιτεκτονική x86
  ```

- **Προβολή της δεκαδικής τιμής μιας δεκαεξαδικής**:

  ```sh
  p /d 0xaddress
  ```

- **Προβολή των 5 επόμενων εντολών από τον instruction pointer**:
  ```sh
  x/5i $rip  # Για αρχιτεκτονική x86_64
  x/5i $eip  # Για αρχιτεκτονική x86
  ```

Αυτές οι εντολές μας βοηθούν να αναλύσουμε τη ροή εκτέλεσης, να εντοπίσουμε κρίσιμα σημεία στη στοίβα και να κατανοήσουμε πώς μπορεί να γίνει εκμετάλλευση μέσω buffer overflow.
